---
alwaysApply: false
---
{
  "name": "Builder Pattern Implementation",
  "description": "Rules for implementing the Builder design pattern in Python",
  "rules": [
    {
      "name": "builder_interface_rule",
      "description": "Define the Builder interface with abstract methods for each part",
      "instruction": "Always create an abstract Builder class with @abstractmethod decorators for each production step. Include a product property to retrieve the final product.",
      "examples": [
        {
          "code": "from abc import ABC, abstractmethod\n\nclass Builder(ABC):\n    @property\n    @abstractmethod\n    def product(self):\n        pass\n    \n    @abstractmethod\n    def produce_part_a(self):\n        pass\n    \n    @abstractmethod\n    def produce_part_b(self):\n        pass"
        }
      ]
    },
    {
      "name": "concrete_builder_rule",
      "description": "Implement concrete builders with reset functionality",
      "instruction": "Concrete builders should inherit from Builder, implement all abstract methods, and include a reset() method to create new product instances. Use a _product attribute to hold the current product.",
      "examples": [
        {
          "code": "class ConcreteBuilder1(Builder):\n    def __init__(self):\n        self.reset()\n    \n    def reset(self):\n        self._product = Product1()\n    \n    @property\n    def product(self):\n        product = self._product\n        self.reset()\n        return product\n    \n    def produce_part_a(self):\n        self._product.add(\"PartA1\")"
        }
      ]
    },
    {
      "name": "product_class_rule",
      "description": "Create product classes with part management",
      "instruction": "Product classes should have methods to add parts and display them. Use a list to store parts and provide methods like add() and list_parts().",
      "examples": [
        {
          "code": "class Product1():\n    def __init__(self):\n        self.parts = []\n    \n    def add(self, part):\n        self.parts.append(part)\n    \n    def list_parts(self):\n        print(f\"Product parts: {', '.join(self.parts)}\")"
        }
      ]
    },
    {
      "name": "director_class_rule",
      "description": "Implement Director class for construction sequences",
      "instruction": "The Director class should have a builder setter and methods that define specific construction sequences. It should not know about concrete builder implementations.",
      "examples": [
        {
          "code": "class Director:\n    def __init__(self):\n        self._builder = None\n    \n    @property\n    def builder(self):\n        return self._builder\n    \n    @builder.setter\n    def builder(self, builder):\n        self._builder = builder\n    \n    def build_minimal_viable_product(self):\n        self.builder.produce_part_a()\n    \n    def build_full_featured_product(self):\n        self.builder.produce_part_a()\n        self.builder.produce_part_b()\n        self.builder.produce_part_c()"
        }
      ]
    },
    {
      "name": "client_usage_rule",
      "description": "Show client code usage pattern",
      "instruction": "Demonstrate how clients should use the pattern with Director for standard products and directly with Builder for custom products.",
      "examples": [
        {
          "code": "# Client usage with Director\ndirector = Director()\nbuilder = ConcreteBuilder1()\ndirector.builder = builder\n\nprint(\"Standard product:\")\ndirector.build_minimal_viable_product()\nbuilder.product.list_parts()\n\nprint(\"\\nCustom product:\")\nbuilder.produce_part_a()\nbuilder.produce_part_b()\nbuilder.product.list_parts()"
        }
      ]
    },
    {
      "name": "naming_conventions",
      "description": "Follow consistent naming conventions",
      "instruction": "Use 'Builder' for interface, 'ConcreteBuilderX' for implementations, 'ProductX' for products, and 'Director' for the director class. Method names should follow produce_part_x pattern.",
      "examples": [
        {
          "code": "# Good naming\nclass DatabaseQueryBuilder(Builder):\n    def produce_select_clause(self): ...\n    def produce_where_clause(self): ...\n    def produce_order_by_clause(self): ..."
        }
      ]
    },
    {
      "name": "flexibility_rule",
      "description": "Ensure pattern flexibility",
      "instruction": "The pattern should allow clients to build products step by step without Director, and different builders should be able to create unrelated products.",
      "examples": [
        {
          "code": "# Can use without Director\nbuilder = ConcreteBuilder1()\nbuilder.produce_part_a()\nbuilder.produce_part_c()  # Skip part B if needed\nproduct = builder.product"
        }
      ]
    }
  ],
  "filePatterns": [
    "**/*builder*.py",
    "**/*_builder.py",
    "**/builders/*.py"
  ]
}